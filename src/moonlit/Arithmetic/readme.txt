【该数列有很多奇妙的属性】
	比如：随着数列项数的增加，前一项与后一项之比越逼近黄金分割0.6180339887…… 
	还有一项性质，从第二项开始，每个奇数项的平方都比前后两项之积多1，每个偶数项的平方都比前后两项之积少1。
	如果你看到有这样一个题目：某人把一个8*8的方格切成四块，拼成一个5*13的长方形，故作惊讶地问你：为什么64＝65？其实就是利用了斐波那契数列的这个性质：5、8、13正是数列中相邻的三项，事实上前后两块的面积确实差1，只不过后面那个图中有一条细长的狭缝，一般人不容易注意到。

	如果任意挑两个数为起始，比如5、-2.4，然后两项两项地相加下去，形成5、-2.4、2.6、0.2、2.8、3、5.8、8.8、14.6……等，你将发现随着数列的发展，前后两项之比也越来越逼近黄金分割，且某一项的平方与前后两项之积的差值也交替相差某个值。

	斐波那契数列的第n项同时也代表了集合{1,2,...,n}中所有不包含相邻正整数的子集个数。

	斐波那契数列（f(n)，f(0)=1，f(1)=1，f(2)=2，f(3)=3……）的其他性质：
	1.f(0)+f(1)+f(2)+…+f(n)=f(n+2)-1
	2.f(1)+f(3)+f(5)+…+f(2n-1)=f(2n)-1
	3.f(0)+f(2)+f(4)+…+f(2n)=f(2n+1)-1
	4.[f(0)]^2+[f(1)]^2+…+[f(n)]^2=f(n)·f(n+1)
	5.f(0)-f(1)+f(2)-…+(-1)^n·f(n)=(-1)^n·[f(n+1)-f(n)]+1
	6.f(m+n)=f(m-1)·f(n-1)+f(m)·f(n)
	7.[f(n)]^2=(-1)^(n-1)+f(n-1)·f(n+1)
	8.f(2n-1)=[f(n)]^2-[f(n-2)]^2

【与之相关的数学问题】
	1.排列组合.
		有一段楼梯有10级台阶,规定每一步只能跨一级或两级,要登上第10级台阶有几种不同的走法? 
		这就是一个斐波那契数列：登上第一级台阶有一种登法；登上两级台阶，有两种登法；登上三级台阶，有三种登法；登上四级台阶，有五种登法……
		1，2，3，5，8，13……所以，登上十级，有89种
	2.数列中相邻两项的前项比后项的极限.
		就是问，当n趋于无穷大时，F(n)/F(n+1)的极限是多少？
		这个可由它的通项公式直接得到，极限是(-1+√5)/2，这个就是所谓的黄金分割点，也是代表大自然的和谐的一个数字。
	3.求递推数列a(n)=1,a(n+1)=1+1/a(n).的通项公式.
		由数学归纳法可以得到：a(n)=F(n+1)/F(n).将菲波那契数列的通项式代入，化简就得结果。
	除了具有a(n+2)=an+a(n+1)/的性质外，还可以证明通项公式为：an=1/√[（1＋√5/2) n-(1-√5/2) n](n=1,2,3.....）

【斐波那挈数列通项公式的推导】
	斐波那契数列：1，1，2，3，5，8，13，21…… 
	如果设F(n)为该数列的第n项(n∈N+)。那么这句话可以写成如下形式：
	F(1)=F(2)=1,F(n)=F(n-1)+F(n-2) (n≥3)
	显然这是一个线性递推数列。

	通项公式的推导方法一：利用特征方程

		线性递推数列的特征方程为：X^2=X+1
		解得 X1=(1+√5)/2, X2=(1-√5)/2.

		则F(n)=C1*X1^n + C2*X2^n
		∵F(1)=F(2)=1
		∴C1*X1 + C2*X2
		C1*X1^2 + C2*X2^2
		解得C1=1/√5，C2=-1/√5

		∴F(n)=(1/√5)*{[(1+√5)/2]^n - [(1-√5)/2]^n}【√5表示根号5】

	通项公式的推导方法二：普通方法

		设常数r,s
		使得F(n)-r*F(n-1)=s*[F(n-1)-r*F(n-2)]
		则r+s=1, -rs=1

		n≥3时，有
		F(n)-r*F(n-1)=s*[F(n-1)-r*F(n-2)]
		F(n-1)-r*F(n-2)=s*[F(n-2)-r*F(n-3)]
		F(n-2)-r*F(n-3)=s*[F(n-3)-r*F(n-4)]
		……
		F(3)-r*F(2)=s*[F(2)-r*F(1)]

		将以上n-2个式子相乘，得：
		F(n)-r*F(n-1)=[s^(n-2)]*[F(2)-r*F(1)]
		∵s=1-r，F(1)=F(2)=1
		上式可化简得：
		F(n)=s^(n-1)+r*F(n-1) 

		那么：
		F(n)=s^(n-1)+r*F(n-1)
			= s^(n-1) + r*s^(n-2) + r^2*F(n-2)
			= s^(n-1) + r*s^(n-2) + r^2*s^(n-3) + r^3*F(n-3)
			……
			= s^(n-1) + r*s^(n-2) + r^2*s^(n-3) +……+ r^(n-2)*s + r^(n-1)*F(1)
			= s^(n-1) + r*s^(n-2) + r^2*s^(n-3) +……+ r^(n-2)*s + r^(n-1)
			（这是一个以s^(n-1)为首项、以r^(n-1)为末项、r/s为公差的等比数列的各项的和）
			=[s^(n-1)-r^(n-1)*r/s]/(1-r/s)
			=(s^n - r^n)/(s-r)

		r+s=1, -rs=1的一解为 s=(1+√5)/2, r=(1-√5)/2
		则F(n)=(1/√5)*{[(1+√5)/2]^n - [(1-√5)/2]^n}

【数列与矩阵】
	对于斐波那契数列1,1,2,3,5,8,13…….有如下定义
	F(n)=f(n-1)+f(n-2)
	F(1)=1
	F(2)=1
	对于以下矩阵乘法
	F(n+1) = 1 1 * F(n)
	F(n) 1 0 F(n-1)
	它的运算就是
	F(n+1)=F(n)+F(n-1)
	F(n)=F(n)
	可见该矩阵的乘法完全符合斐波那契数列的定义
	设1 为B，1 1为C
	1 1 0
	可以用迭代得到:
	斐波那契数列的某一项F(n)=(BC^(n-2))1
	这就是斐波那契数列的矩阵乘法定义.
	另矩阵乘法的一个运算法则A&not;^n(n为偶数)=A^(n/2)* A^(n/2).
	因此可以用递归的方法求得答案.
	时间效率：O(logn)，比模拟法O(n)远远高效。
	代码（PASCAL）
	{变量matrix是二阶方阵, matrix是矩阵的英文}
	program fibonacci;
	type
	matrix=array[1..2,1..2] of qword;
	var
	c,cc:matrix;
	n:integer;
	function multiply(x,y:matrix):matrix;
	var
	temp:matrix;
	begin
	temp[1,1]:=x[1,1]*y[1,1]+x[1,2]*y[2,1];
	temp[1,2]:=x[1,1]*y[1,2]+x[1,2]*y[2,2];
	temp[2,1]:=x[2,1]*y[1,1]+x[2,2]*y[2,1];
	temp[2,2]:=x[2,1]*y[1,2]+x[2,2]*y[2,2];
	exit(temp);
	end;
	function getcc(n:integer):matrix;
	var
	temp:matrix;
	t:integer;
	begin
	if n=1 then exit(c);
	t:=n div 2;
	temp:=getcc(t);
	temp:=multiply(temp,temp);
	if odd(n) then exit(multiply(temp,c))
	else exit(temp);
	end;
	procedure init;
	begin
	readln(n);
	c[1,1]:=1;
	c[1,2]:=1;
	c[2,1]:=1;
	c[2,2]:=0;
	if n=1 then
	begin
	writeln(1);
	halt;
	end;
	if n=2 then
	begin
	writeln(1);
	halt;
	end;
	cc:=getcc(n-2);
	end;
	procedure work;
	begin
	writeln(cc[1,1]+cc[1,2]);
	end;
	begin
	init;
	work;
	end.

【数列值的另一种求法】
F(n) = [ (( sqrt ( 5 ) + 1 ) / 2) ^ n ]
其中[ x ]表示取距离 x 最近的整数。
